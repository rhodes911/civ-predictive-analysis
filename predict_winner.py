#!/usr/bin/env python3
"""
Live Victory Prediction Interface
=================================

This script uses the trained Random Forest model to predict winners
of ongoing Civ VI games based on current Turn 20+ data.

Prerequisites:
    - trained_model.pkl (generated by victory_prediction_model.py)
    - Database connection to live game data

Usage:
    python predict_winner.py

Output:
    - Live predictions for current game
    - Win probabilities for each civilization
    - Strategic insights and recommendations
"""

import pandas as pd
import numpy as np
import pickle
import psycopg2
from datetime import datetime
import os

class LiveVictoryPredictor:
    def __init__(self):
        """Initialize the live victory prediction system"""
        self.model = None
        self.feature_columns = [
            # Raw metrics
            'num_cities', 'population', 'techs', 'civics',
            'yields_science', 'yields_culture', 'yields_production',
            'buildings', 'districts', 'current_score', 'game_turn',
            # Calculated features
            'science_per_city', 'population_per_city', 'buildings_per_city',
            'development_index',
            # Relative rankings
            'science_rank', 'cities_rank', 'score_rank', 'population_rank'
        ]
        self.db_config = {
            'host': 'localhost',
            'port': 5432,
            'database': 'civ6_analytics',
            'user': 'civ6_user',
            'password': 'civ6_password'
        }
    
    def load_trained_model(self):
        """Load the trained Random Forest model"""
        try:
            if not os.path.exists('trained_model.pkl'):
                print("âŒ trained_model.pkl not found!")
                print("   Please run victory_prediction_model.py first")
                return False
                
            with open('trained_model.pkl', 'rb') as f:
                self.model = pickle.load(f)
            
            print("âœ… Trained model loaded successfully")
            return True
            
        except Exception as e:
            print(f"âŒ Error loading model: {e}")
            return False
    
    def connect_database(self):
        """Establish database connection"""
        try:
            conn = psycopg2.connect(**self.db_config)
            return conn
        except Exception as e:
            print(f"âŒ Database connection failed: {e}")
            return None
    
    def get_current_game_data(self):
        """Get the latest game data for prediction"""
        conn = self.connect_database()
        if not conn:
            return None
        
        try:
            # Get the most recent game data (latest turn from latest session)
            latest_data_query = """
            SELECT 
                civilization,
                game_turn,
                num_cities,
                population,
                techs,
                civics,
                yields_science,
                yields_culture,
                yields_production,
                buildings,
                districts,
                total_score,
                created_at,
                -- Calculate relative rankings for this turn
                RANK() OVER (ORDER BY yields_science DESC) as science_rank,
                RANK() OVER (ORDER BY num_cities DESC) as cities_rank,
                RANK() OVER (ORDER BY total_score DESC) as score_rank,
                RANK() OVER (ORDER BY population DESC) as population_rank
            FROM civ_game_data 
            WHERE (created_at, game_turn) = (
                SELECT created_at, MAX(game_turn)
                FROM civ_game_data 
                GROUP BY created_at
                ORDER BY created_at DESC
                LIMIT 1
            )
            ORDER BY total_score DESC;
            """
            
            current_data = pd.read_sql(latest_data_query, conn)
            conn.close()
            
            if len(current_data) == 0:
                print("âŒ No current game data found")
                return None
            
            latest_turn = current_data.iloc[0]['game_turn']
            latest_session = current_data.iloc[0]['created_at']
            num_civs = len(current_data)
            
            print(f"ğŸ“Š Found current game: {latest_session}")
            print(f"   Latest turn: {latest_turn}, Civilizations: {num_civs}")
            
            # Calculate derived features
            current_data['current_score'] = current_data['total_score']
            current_data['science_per_city'] = np.where(
                current_data['num_cities'] > 0,
                current_data['yields_science'] / current_data['num_cities'],
                0
            )
            current_data['population_per_city'] = np.where(
                current_data['num_cities'] > 0,
                current_data['population'] / current_data['num_cities'],
                0
            )
            current_data['buildings_per_city'] = np.where(
                current_data['num_cities'] > 0,
                current_data['buildings'] / current_data['num_cities'],
                0
            )
            current_data['development_index'] = np.where(
                current_data['game_turn'] > 0,
                (current_data['techs'] + current_data['civics']) / current_data['game_turn'],
                0
            )
            
            return current_data, latest_turn
            
        except Exception as e:
            print(f"âŒ Error getting current game data: {e}")
            conn.close()
            return None
    
    def make_predictions(self, current_data):
        """Make victory predictions for current game"""
        if self.model is None:
            print("âŒ Model not loaded")
            return None
        
        try:
            # Prepare features for prediction
            X = current_data[self.feature_columns]
            
            # Handle any missing features
            for col in self.feature_columns:
                if col not in X.columns:
                    X[col] = 0
                X[col] = X[col].fillna(0)
            
            # Get win probabilities
            win_probabilities = self.model.predict_proba(X)[:, 1]
            
            # Create results dataframe
            results = pd.DataFrame({
                'civilization': current_data['civilization'],
                'win_probability': win_probabilities,
                'current_score': current_data['total_score'],
                'science_rank': current_data['science_rank'],
                'cities_rank': current_data['cities_rank'],
                'score_rank': current_data['score_rank'],
                'num_cities': current_data['num_cities'],
                'yields_science': current_data['yields_science'],
                'techs': current_data['techs']
            }).sort_values('win_probability', ascending=False)
            
            return results
            
        except Exception as e:
            print(f"âŒ Error making predictions: {e}")
            return None
    
    def analyze_predictions(self, results, current_turn):
        """Analyze and interpret predictions"""
        if results is None or len(results) == 0:
            return
        
        print(f"\nğŸ† VICTORY PREDICTIONS - Turn {current_turn}")
        print("=" * 80)
        
        # Main predictions table
        print(f"{'Rank':<4} {'Civilization':<12} {'Win Prob':<10} {'Score':<8} {'Cities':<8} {'Science':<8} {'Techs':<6}")
        print("-" * 80)
        
        for i, (_, row) in enumerate(results.iterrows(), 1):
            prob_str = f"{row['win_probability']:.1%}"
            
            # Add confidence indicators
            if row['win_probability'] >= 0.7:
                indicator = "ğŸ”¥"
            elif row['win_probability'] >= 0.4:
                indicator = "âš¡"
            elif row['win_probability'] >= 0.15:
                indicator = "ğŸ“ˆ"
            else:
                indicator = "ğŸ“‰"
            
            print(f"{i:<4} {row['civilization']:<12} {prob_str:<10} {row['current_score']:<8.0f} "
                  f"{row['num_cities']:<8.0f} {row['yields_science']:<8.0f} {row['techs']:<6.0f} {indicator}")
        
        print("\nğŸ¯ PREDICTION CONFIDENCE:")
        top_prediction = results.iloc[0]
        
        if top_prediction['win_probability'] >= 0.7:
            print(f"ğŸ”¥ HIGH CONFIDENCE: {top_prediction['civilization']} very likely to win ({top_prediction['win_probability']:.1%})")
        elif top_prediction['win_probability'] >= 0.4:
            print(f"âš¡ MODERATE CONFIDENCE: {top_prediction['civilization']} favored but game still competitive")
        else:
            print(f"ğŸ“Š LOW CONFIDENCE: Game appears wide open, no clear frontrunner")
        
        # Competitive analysis
        print(f"\nğŸ“Š COMPETITIVE ANALYSIS:")
        competitive_civs = results[results['win_probability'] >= 0.15]
        
        if len(competitive_civs) <= 2:
            print(f"   Two-horse race between top {len(competitive_civs)} civilizations")
        elif len(competitive_civs) <= 3:
            print(f"   Tight three-way competition")
        else:
            print(f"   Wide open field with {len(competitive_civs)} competitive civilizations")
        
        # Underdog analysis
        underdog = results.iloc[-1]
        if underdog['win_probability'] < 0.05:
            print(f"   {underdog['civilization']} facing elimination ({underdog['win_probability']:.1%} chance)")
        
        return top_prediction
    
    def generate_strategic_insights(self, results, current_turn):
        """Generate strategic insights and recommendations"""
        if results is None or len(results) == 0:
            return
        
        print(f"\nğŸ’¡ STRATEGIC INSIGHTS - Turn {current_turn}")
        print("=" * 50)
        
        # Leader analysis
        leader = results.iloc[0]
        print(f"ğŸ¥‡ CURRENT LEADER: {leader['civilization']}")
        print(f"   Win Probability: {leader['win_probability']:.1%}")
        print(f"   Key Strengths:")
        
        if leader['science_rank'] <= 2:
            print(f"   ğŸ§ª Science Leadership (Rank #{leader['science_rank']:.0f})")
        if leader['cities_rank'] <= 2:
            print(f"   ğŸ™ï¸  Expansion Advantage (Rank #{leader['cities_rank']:.0f})")
        if leader['score_rank'] <= 2:
            print(f"   ğŸ“Š Score Dominance (Rank #{leader['score_rank']:.0f})")
        
        # Challenger analysis
        if len(results) > 1:
            challenger = results.iloc[1]
            print(f"\nğŸ¥ˆ MAIN CHALLENGER: {challenger['civilization']}")
            print(f"   Win Probability: {challenger['win_probability']:.1%}")
            print(f"   Gap to close: {(leader['win_probability'] - challenger['win_probability']) * 100:.1f} percentage points")
        
        # Critical thresholds
        print(f"\nâš ï¸  CRITICAL THRESHOLDS:")
        science_leader = results.loc[results['science_rank'] == 1, 'civilization'].iloc[0]
        cities_leader = results.loc[results['cities_rank'] == 1, 'civilization'].iloc[0]
        
        print(f"   ğŸ§ª Science Leader: {science_leader}")
        print(f"   ğŸ™ï¸  Cities Leader: {cities_leader}")
        
        if science_leader == cities_leader:
            print(f"   ğŸ”¥ {science_leader} dominates both science AND expansion!")
        
        # Comeback potential
        print(f"\nğŸ”„ COMEBACK POTENTIAL:")
        bottom_half = results[len(results)//2:]
        viable_comebacks = bottom_half[bottom_half['win_probability'] >= 0.10]
        
        if len(viable_comebacks) > 0:
            print(f"   Civilizations with comeback potential:")
            for _, civ in viable_comebacks.iterrows():
                print(f"   ğŸ“ˆ {civ['civilization']}: {civ['win_probability']:.1%} chance")
        else:
            print(f"   âŒ Little comeback potential - top civilizations pulling away")
        
        # Turn-specific insights
        if current_turn <= 30:
            print(f"\nğŸš€ EARLY GAME INSIGHTS (Turn {current_turn}):")
            print(f"   Still time for strategic pivots and expansion")
        elif current_turn <= 60:
            print(f"\nâš¡ MID GAME INSIGHTS (Turn {current_turn}):")
            print(f"   Key infrastructure and military decisions critical")
        else:
            print(f"\nğŸ LATE GAME INSIGHTS (Turn {current_turn}):")
            print(f"   Victory conditions becoming clearer")
    
    def save_prediction_log(self, results, current_turn):
        """Save predictions to log file for tracking accuracy"""
        try:
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            log_entry = f"\n--- PREDICTION LOG - Turn {current_turn} - {timestamp} ---\n"
            for _, row in results.iterrows():
                log_entry += f"{row['civilization']}: {row['win_probability']:.3f}\n"
            log_entry += "\n"
            
            with open('prediction_log.txt', 'a', encoding='utf-8') as f:
                f.write(log_entry)
            
            print(f"âœ… Predictions logged to: prediction_log.txt")
            
        except Exception as e:
            print(f"âš ï¸  Could not save prediction log: {e}")
    
    def run_prediction(self):
        """Run the complete prediction process"""
        print("ğŸš€ Starting Live Victory Prediction")
        print("=" * 40)
        
        # Step 1: Load trained model
        if not self.load_trained_model():
            return False
        
        # Step 2: Get current game data
        print("\nğŸ“¡ Fetching current game data...")
        game_data = self.get_current_game_data()
        
        if game_data is None:
            return False
        
        current_data, current_turn = game_data
        
        # Step 3: Make predictions
        print(f"\nğŸ¯ Making victory predictions for Turn {current_turn}...")
        results = self.make_predictions(current_data)
        
        if results is None:
            return False
        
        # Step 4: Analyze and display predictions
        top_prediction = self.analyze_predictions(results, current_turn)
        
        # Step 5: Generate strategic insights
        self.generate_strategic_insights(results, current_turn)
        
        # Step 6: Save prediction log
        self.save_prediction_log(results, current_turn)
        
        print(f"\nğŸ‰ Prediction complete!")
        print(f"ğŸ’¡ Recommended action: Monitor {top_prediction['civilization']} as likely winner")
        
        return True

def run_quick_prediction():
    """Quick prediction function for easy testing"""
    predictor = LiveVictoryPredictor()
    return predictor.run_prediction()

if __name__ == "__main__":
    # Run the live prediction
    run_quick_prediction()
